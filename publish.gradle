/*
 * JustEnoughPublishing: automatically publish minecraft mods to CurseForge and Github Releases
 * LICENSE : Public Domain, https://creativecommons.org/publicdomain/zero/1.0
 * AUTHOR  : LukeGrahamLandry#6888
 * SOURCE  : https://moddingtutorials.org/publish.gradle
 *
 * Usage:
 * 1. import this script (bottom of build.gradle)
 *    apply from: "https://moddingtutorials.org/publish.gradle"
 * 2. create the config file .github/publish.json as specified bellow
 * 3. define your api keys as environment variables and make sure you expose the required gradle properties
 * 4. create a github action to run `./gradlew publishMod` whenever you want to publish a new version
 *
 * Structure of the config file (location options in order: {root}/.github/publish.json > {subproject}/publish.json > {root}/publish.json):
 * - versions: array of supported minecraft versions. ie ["1.19.3", "1.19.2"]
 * - loader: "forge" or "fabric"
 * - changelogUrl: url will be added to description body (optional, a changelog.txt file may be used instead)
 * - releaseType: default "release", could also be "beta" or "alpha"
 * - github: (optional)
 *      - repo: the name of the repository to release to
 *      - owner: the name of the github account that owns repo
 *      - branch: the name of the branch this release is based on
 *      - requiredDependencies: map of display name to url (optional)
 * - curseforge: (optional)
 *      - id: the id of the project to publish the file (as a string)
 *      - requiredDependencies: list of project slugs (optional)
 *
 * - modrinth: (optional)
 *      - id: the id of the project to publish the file (as a string)
 *      - requiredDependencies: list of project slugs (optional)
 * Required gradle.properties variables:
 * - version
 *
 * Environment variables: (can also be set in USER_HOME_FOLDER/.gradle/gradle.properties)
 * - CURSEFORGE_API_KEY: https://authors.curseforge.com/account/api-tokens
 * - GH_API_KEY: personal token with repo permissions https://github.com/settings/tokens
 */

buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://maven.architectury.dev" }
    }
    dependencies {
        classpath 'com.google.code.gson:gson:2.8.2'

        classpath "me.shedaniel.unified-publishing:me.shedaniel.unified-publishing.gradle.plugin:0.1.10"
        classpath "com.matthewprenger.cursegradle:com.matthewprenger.cursegradle.gradle.plugin:1.4.0"
        classpath "com.github.breadmoirai.github-release:com.github.breadmoirai.github-release.gradle.plugin:2.4.1"
    }
}

import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.util.Map
import java.util.HashMap
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException

//////// START DEPENDENCY PLUGINS ////////////

// i dont want to have to apply the plugins from the main build.gradle file
// there's a thing for resolving transient dependencies but i think it requires building a jar from the plugin and shoving that in maven somewhere which i dont want to deal with 
// seems like i cant apply (plugins that i added to buildscript classpath) by id
// so instead have to import the plugin class and apply it that way
// but unifiedpublishing tries to apply com.matthewprenger.cursegradle by id
// which i can't do so i have my own wrapper plugin that adds their extension and task without trying to apply the dependency

import me.shedaniel.unifiedpublishing.UnifiedPublishingExtension;
import com.matthewprenger.cursegradle.CurseGradlePlugin
import com.github.breadmoirai.githubreleaseplugin.GithubReleasePlugin

class UnifiedPublishingWrapper implements Plugin<Project> {
    void apply(Project project) {
        Task task = project.getTasks().maybeCreate("publishUnified")
        project.afterEvaluate(proj -> proj.getExtensions().getByType(UnifiedPublishingExtension.class).onConfigure(proj, task))
        project.getExtensions().create("unifiedPublishing", UnifiedPublishingExtension.class, project)
    }
}

apply plugin: UnifiedPublishingWrapper
apply plugin: CurseGradlePlugin
apply plugin: GithubReleasePlugin

//////// END DEPENDENCY PLUGINS ////////////


class JustEnoughPublishing {
    class CurseforgePublishConfig {
        String id;
        String[] requiredDependencies;
    }

    class ModrinthPublishConfig {
        String id;
        String[] requiredDependencies;
    }

    class GithubPublishConfig {
        String owner;
        String repo;
        String branch;
        Map<String, String> requiredDependencies;
    }

    class PublishConfig {
        CurseforgePublishConfig curseforge = null;
        GithubPublishConfig github = null;
        ModrinthPublishConfig modrinth = null;
        String loader;
        String changelogUrl;
        String[] mc_versions;
        String releaseType = "release"
    }

    PublishConfig config;
    String prettyName;
    String cfToken;
    String ghToken;
    String mrToken;
    String changelogText;

    Project parentProject
    JustEnoughPublishing(Project parentProject) {
        this.parentProject = parentProject
        this.config = this.loadConfig();
        if (this.config == null) return;
        this.prettyName = this.parentProject.version + " " + this.config.loader
        if (!this.prettyName .contains("+")) this.prettyName += " " + this.config.mc_versions[0];

        if (this.config.curseforge != null || this.config.modrinth != null) this.platform();
        if (this.config.github != null) this.github();
    }

    void log(String s){
        println "[JustEnoughPublishing] " + s
    }

    String loadChangelog(){
        String defaultChangelog = this.config.changelogUrl == null ? null : "See ${this.config.changelogUrl} for full details";
        File changelog = this.locateFile("CHANGELOG.md");
        if (changelog == null) defaultChangelog;
        String specificChangelog = changelog.getText('UTF-8')
        if (specificChangelog.isEmpty()) return defaultChangelog;
        return "##" + specificChangelog.split("##")[1];
    }

    File locateFile(String filename){
        List<File> locations = [new File(new File(this.parentProject.rootDir, ".github"), filename), new File(this.parentProject.projectDir, filename), new File(this.parentProject.rootDir, filename)]

        File dataFile = null;
        for (int i=0;i<locations.size();i++){
            dataFile = locations.get(i);
            this.log("checking for file: " + dataFile.toString())
            if (dataFile.exists()) break
            else dataFile = null;
        }
        return dataFile;
    }

    PublishConfig loadConfig(){
        File dataFile = locateFile("publish.json");
        if (dataFile == null){
            this.log("Missing config file")
            return null;
        }

        List<String> lines = Files.readAllLines(dataFile.toPath(), StandardCharsets.UTF_8);
        String data = String.join("\n", lines);
        Gson GSON = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
        try {
            this.config = GSON.fromJson(data, PublishConfig.class);
        } catch (JsonSyntaxException e){
            e.printStackTrace();
            this.log("Failed to parse config file: " + dataFile.toString() + "\n" + data);
            return null;
        }

        if (this.config.mc_versions == null || this.config.loader == null){
            this.log("Config requires keys 'mc_versions', 'loader'. will not publish mod.");
            return null;
        }

        this.changelogText = this.loadChangelog();
        if (this.changelogText == null){
            this.log("Either the config key 'changelogUrl' or a 'CHANGELOG.md' file is required. will not publish mod.")
            return null;
        }

        if (this.config.releaseType == null) this.config.releaseType = "release";

        this.cfToken = this.parentProject.findProperty("CURSEFORGE_API_KEY") ?: System.getenv("CURSEFORGE_API_KEY")
        if (this.config.curseforge == null){
            this.log("Missing key 'curseforge' in config, will not publish to curseforge.");
        } else if (this.cfToken == null){
            this.log("Missing env variable CURSEFORGE_API_KEY, will not publish to curseforge.");
            this.config.curseforge = null;
        } else if (this.config.curseforge.id == null){
            this.log("Config[curseforge] requires key 'id'. will not publish to curseforge.");
            this.config.curseforge = null;
        }

        this.ghToken = this.parentProject.findProperty("GH_API_KEY") ?: System.getenv("GH_API_KEY")
        if (this.config.github == null){
            this.log("Missing key 'github' in config. will not publish to github.");
        } else if (this.ghToken == null){
            this.config.github = null;
            this.log("Missing env variable GH_API_KEY, will not publish to github.");
        } else if (this.config.github.repo == null || this.config.github.branch == null || this.config.github.owner == null){
            this.log("Config[github] requires keys 'repo', 'owner', 'branch'. will not publish to github.");
            this.config.github = null;
        }

        this.mrToken = this.parentProject.findProperty("MODRINTH_API_KEY") ?: System.getenv("MODRINTH_API_KEY")
        if (this.config.modrinth == null){
            this.log("Missing key 'modrinth' in config. will not publish to modrinth.");
        } else if (this.mrToken == null){
            this.config.modrinth = null;
            this.log("Missing env variable MODRINTH_API_KEY, will not publish to modrinth.");
        } else if (this.config.modrinth.id == null){
            this.log("Config[modrinth] requires key 'id'. will not publish to modrinth.");
            this.config.modrinth = null;
        }

        if (this.config.github == null && this.config.curseforge == null && this.config.modrinth == null){
            this.log("No valid publishing targets")
            return null;
        }

        return this.config;
    }


    // https://github.com/shedaniel/unified-publishing
    // gradlew publishUnified
    void platform(){
        String tag = this.parentProject.version;
        if (!this.parentProject.version.contains("+")) tag += "+" + this.config.mc_versions[0];

       this.parentProject.unifiedPublishing {
            project {
                releaseType = this.config.releaseType
                displayName = this.prettyName
                version = tag
                changelog = this.changelogText;
                gameVersions = List.of(this.config.mc_versions)
                gameLoaders = this.config.loader.equals("forge") ? ["forge"] : ["fabric", "quilt"]

                mainPublication this.parentProject.hasProperty("remapJar") ? this.parentProject.remapJar : this.parentProject.jar

                if (this.config.curseforge != null){
                    curseforge {
                        token = cfToken
                        id = this.config.curseforge.id
                        if (this.config.curseforge.requiredDependencies != null){
                            relations {
                                for (String slug : List.of(this.config.curseforge.requiredDependencies)){
                                    depends slug
                                }
                            }
                        }
                    }
                }

                if (this.config.modrinth != null){
                    modrinth {
                        token = mrToken
                        id = this.config.modrinth.id
                        if (this.config.modrinth.requiredDependencies != null) {
                            relations {
                                for (String slug : List.of(this.config.modrinth.requiredDependencies)) {
                                    depends slug
                                }
                            }
                        }
                    }
                }

            }
        }
    }

    void github(){
        String changelogInfo = this.changelogText;
        changelogInfo += """\nSupported MC Versions: **${String.join(", ", this.config.mc_versions)}**  \nSupported Mod Loader: **${this.config.loader}**  \n"""

        if (this.config.github.requiredDependencies != null){
            changelogInfo += "## Required Dependencies \n";
            for (Map.Entry<String, String> dep : this.config.github.requiredDependencies){
                changelogInfo += "- [${dep.getKey()}](${dep.getValue()}) \n"
            }
        }

        String tag = this.parentProject.version + "+" + this.config.loader;
        if (!this.parentProject.version.contains("+")) tag += "+" + this.config.mc_versions[0];

        this.parentProject.githubRelease {
            token this.ghToken
            owner this.config.github.owner
            repo this.config.github.repo
            tagName tag
            targetCommitish this.config.github.branch
            releaseName this.prettyName
            body changelogInfo
            generateReleaseNotes false
            draft false
            releaseAssets this.parentProject.hasProperty("remapJar") ? this.parentProject.remapJar.archiveFile : this.parentProject.jar.archiveFile
            allowUploadToExisting false
            overwrite false
            apiEndpoint "https://api.github.com"
            client
        }
    }
}

class JustEnoughPublishingPlugin implements Plugin<Project> {
    void apply(Project project){
        JustEnoughPublishing publisher = new JustEnoughPublishing(project)
        if (publisher.config == null) return;

        project.tasks.register("publishMod") {
            dependsOn(project.tasks.build)

            List<String> targets = new ArrayList<>();
            if (publisher.config.curseforge != null || publisher.config.modrinth != null) finalizedBy(project.tasks.publishUnified)
            if (publisher.config.curseforge != null) targets.add("curseforge");
            if (publisher.config.modrinth != null) targets.add("modrinth");
            if (publisher.config.github != null) {
                finalizedBy(project.tasks.githubRelease)
                targets.add("github")
            }

            publisher.log("active targets: " + String.join(", ", targets))
        }

        publisher.log("registered gradle task: publishMod")
    }
}

apply plugin: JustEnoughPublishingPlugin

// TODO: maven support with sources jar
// TODO: config entry for optional dependencies
// TODO: property to block applying dependency plugins so other people dont have to do similar hack as i did for unifiedPublishing
